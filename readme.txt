6502 Assembly Optimizer
Joey Shepard
joey.m.shepard@gmail.com


OVERVIEW
========
This project analyzes and optimizes assembly language code written for the 6502/65C02 processor.

When 6502 assembly programmers need temporary storage for local variables in a function, they can choose between storing those variables on a stack or assigning the variables a static location in memory. Unfortunately, the 6502 is relatively poor at stack manipulation. Using the stack to store temporary variables is slow and monopolizes processor resources better used for other purposes, leading to slow and inefficient code. On the other hand, avoiding the stack and assigning each local variable a static address in the first 256 bytes of memory is the fastest form of memory access and does not require any other resources. The disadvantage is that these 256 bytes are quickly used up if each byte is assigned to only one variable in one function. This project analyzes program flow and variable usage to statically allocate variable addresses in a way that allows multiple functions to utilize the same memory. This offers the compact memory usage of a stack without sacrificing speed or processor resources and requires no runtime overhead.

The analysis portion of the project fully tokenizes source input, resolves symbols, and preserves symbollic labels. This will allow further improvements besides memory allocation such as peephole optimization.


USAGE
=====
The program starts from main.py in the root folder and uses the file main.i for test input. Main.i is the intermediate output from using Macroassembler AS 1.42 to assemble the test 6502 assembly project located in the "6502 source" folder. After analyzing and optimizing main.i, the project outputs two HTML files to the folder output. Callgraph.html shows the call tree of the assembly language code, as well as the variable allocations generated by the optimizer. In this example, 38 bytes of local variables fit in only 19 bytes of memory. The second file, processed.html, shows the changes made to the source to resolve symbols, assign memory, and generate binary code when necessary. This information is the basis for the optimization steps yet to be implemented.


DEPENDENCIES
============
Python 3. No packages required. 


FILES
=====
main.py
-Execution begins here. It calls each function in turn to read in, parse, simplify, optimize and output the input assembly file. No need to supply command line parameters.

const.py
-Constants related to classifying 6502 instructions, parsing assembly input, and handling errors.

globals.py
-Global variables related to parsing assembly input that need to be visible to all functions, as well as class definitions.

ops.py
-Functions available in assembly source that resolve at compile time. New functions can be added in Python allowing for much more powerful macro functions than available otherwise.

pp_6502.py
-Function for reading in 6502 instruction information from "6502 Optimizer - Instructions.csv" which will be used to optimize instructions by analyzing their effect on processor state during program execution.

parse.py
-Functions related to reading the assembly input in and parsing each line into tokens that have a type (number, string, function, etc)

simplify.py
-Functions related to simplifying assembly input by resolving symbols and performing any calculations in the source.

optimize.py
-Functions related to optimizing the source by generating a call graph and assigning local variable usage.

output.py
-Functions related to outputting the processed and optimized source back to an assembly file and to an HTML file for debugging.

6502 Optimizer - Instructions.csv
-Information describing each 6502 instruction that will be used to optimize instructions by analyzing their effect on processor state during program execution.

main.i
-Example input file generated by Macroassembler AS 1.42 from example 6502 assembly project located in folder "6502 source."

